<h1>Setup of a Linode Server running Arch Linux</h1>

<p>These pseudo-scripts are the actions which are used to configure a remote host
as a web server for one or more Rails based web sites.
They are pseudo-scripts rather than full scripts because some actions are indicated
rather than scripted.</p>

<p>The basic site will look like:</p>

<ul>
<li><strong>ssh</strong> access from a local host (unnamed)</li>
<li>web service via <strong>nginx</strong> which acts as a reverse proxy for the
<strong>'thin'</strong> ruby web server.</li>
<li>a local database running <strong>postgresql</strong></li>
<li>multiple sites

<ul>
<li>each site runs under it's own user id</li>
<li>each site has it's own rvm based ruby installation</li>
<li>each site manages it's own 'thin' web servers and directs monit to monitor them</li>
<li>each site is installed via Capistrano</li>
</ul></li>
<li>the host run's <strong>monit</strong> - which monitors the health of <strong>nginx</strong>,
<strong>postgresql</strong>, <strong>postfix</strong>, and all the <strong>thin</strong> web servers for all
the sites.</li>
<li>the host is firewalled using <strong>iptables</strong> and <strong>iptables6</strong>.</li>
<li>the host runs a minimal set of sesrvices.</li>
</ul>

<p>These notes detail setting up a server running Arch linux.</p>

<p>(There are a few notes for instructions for Ubuntu, but they are
incomplete.)</p>

<h2>Test Driven Host Setup</h2>

<p>The tests/hosts directory contains a bunch of tests which run commands
on hosts - either selected hosts, or all hosts defined in the :hosts role
in the Capfile.</p>

<p>The test parameters may be set by defining environment variables.</p>

<p>For Host Provisioning Testing</p>

<ul>
<li>HOSTS - list of hosts to run tests on. Default is all hosts defined in the
:hosts role of the Capfile</li>
<li>HOST_ADMIN - name of admin user on all hosts (NOT root). Defaults to 'host_admin'</li>
<li>LOCAL_ADMIN - name of admin user on local (maybe development or staging site)
who has the authority to run commands on all hosts. Should be able to ssh into
both HOST_ADMIN and 'root' on all hosts via public key logins. Defaults to
'local_admin'</li>
<li>LOCAL_ADMIN<em>EMAIL - email address of admin who should receive notifications
from all hosts - typically from 'monit'. Defaults to 'local</em>admin@example.com'</li>
</ul>

<h2>TDD Installation</h2>

<p>The <strong>test</strong> directory includes a set of tests to excercise connectivity to the
host and checks that the basic services are installed and running.</p>

<h2>Shell Variables Used in enclosed Scripts</h2>

<p>These variables are used in the pseudo-scripts.</p>

<pre><code>HOST=my host name
ADMIN=name of admin user on HOST - not root
LOCAL_ADMIN=userid of local admin user who has passwordless ssh access
LOCAL_ADMIN_EMAIL=email address of local administrator who should receive notifications
</code></pre>

<h2>set up root ssh access</h2>

<p>We need root ssh access for testing the connection and verifying system level
installs are working</p>

<pre><code>add $LOCAL_ADMIN key to ~root/.ssh/authorized_keys

edit /etc/ssh/sshd_config

PermitRootLogin yes

/etc/rc.d/sshd restart  # arch linux
# service ssh restart     # ubuntu linux

Test ssh root@hostname to make sure it works, then change
PermitRootLogin without-password
</code></pre>

<h2>Create user $ADMIN</h2>

<pre><code>adduser -G monit $ADMIN

(fill in as appropriate)

chmod 711 /home/$ADMIN
</code></pre>

<p>a
    sudo su - $ADMIN</p>

<pre><code>mkdir htdocs
chgrp nginx htdocs
chmod 755 htdocs
chmod g+s htdocs
</code></pre>

<p>Add $ADMIN to sudoer's</p>

<pre><code>vi /etc/sudoers
(add mike as equivalent to root)
</code></pre>

<h2>install packages</h2>

<p>As root</p>

<pre><code>pacman -Su

pacman -Sy

pacman -S nginx ruby iptables postgresql postfix monit git

# yes, we immediately remove ruby. We only install it so that the prerequisites are
#  available to build rubies using 'rvm'. And, yes, it's cheesy, but it works.
pacman -R ruby   
</code></pre>

<h2>setup for iptables</h2>

<pre><code>pacman -S iptables # pulls in both iptables and ip6tables
</code></pre>

<p>These configurations only allow HTTP, HTTPS, and SSH traffic.
The do not work if the dbms is on a separate host or if we need
multiple hosts to do load balancing.</p>

<p>We will resolve this when we need it - hopefully that will coincide
with $$$ to hire it done.</p>

<h3>iptables</h3>

<p>cd /etc/iptables</p>

<pre><code>cat &lt;&lt;-EOF &gt;iptables.rules
# Generated by iptables-save v1.4.10 on Fri Jul  8 04:13:58 2011
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [1676:404831]
:TCP - [0:0]
:UDP - [0:0]
-A INPUT -i lo -j ACCEPT 
-A INPUT -m conntrack --ctstate INVALID -j DROP 
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 
-A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT 
-A INPUT -p udp -m conntrack --ctstate NEW -j UDP 
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP 
-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable 
-A INPUT -p tcp -j REJECT --reject-with tcp-reset 
-A INPUT -j REJECT --reject-with icmp-proto-unreachable 
-A TCP -p tcp -m tcp --dport 22 -j ACCEPT 
-A TCP -p tcp -m tcp --dport 80 -j ACCEPT 
-A TCP -p tcp -m tcp --dport 443 -j ACCEPT 
-A UDP -p udp -m udp --dport 22 -j ACCEPT 
-A UDP -p udp -m udp --dport 80 -j ACCEPT 
-A UDP -p udp -m udp --dport 443 -j ACCEPT 
COMMIT
# Completed on Fri Jul  8 04:13:58 2011
EOF

/etc/rc.d/iptables restart
/etc/rc.d/iptables save
</code></pre>

<h3>ip6tables</h3>

<p>ip6tables has similar, but slightly different syntax. I don't expect
any IPV6 traffic, but there is no reason not to respond and even more
reason not to leave holes open.</p>

<p>cd /etc/iptables</p>

<pre><code>cat &lt;&lt;-EOF &gt;ip6tables.rules
# Generated by iptables-save v1.4.10 on Fri Jul  8 04:13:58 2011
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [1676:404831]
:TCP - [0:0]
:UDP - [0:0]
-A INPUT -i lo -j ACCEPT 
-A INPUT -m conntrack --ctstate INVALID -j DROP 
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 
# echo request
# this is the ipv4 version
# -A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT 
-A INPUT -p icmpv6 -m icmp6 --icmpv6-type 128 -m conntrack --ctstate NEW -j ACCEPT 
-A INPUT -p udp -m conntrack --ctstate NEW -j UDP 
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP 
-A INPUT -p udp -j REJECT --reject-with icmp6-port-unreachable 
-A INPUT -p tcp -j REJECT --reject-with tcp-reset 
-A INPUT -j REJECT --reject-with adm-prohibited
-A TCP -p tcp -m tcp --dport 22 -j ACCEPT 
-A TCP -p tcp -m tcp --dport 80 -j ACCEPT 
-A TCP -p tcp -m tcp --dport 443 -j ACCEPT 
-A UDP -p udp -m udp --dport 22 -j ACCEPT 
-A UDP -p udp -m udp --dport 80 -j ACCEPT 
-A UDP -p udp -m udp --dport 443 -j ACCEPT 
COMMIT
# Completed on Fri Jul  8 04:13:58 2011
</code></pre>

<h2>Enable en_US locale</h2>

<p>run <code>locale -a</code></p>

<p>if it works, then go to nginx</p>

<p>if not, then</p>

<pre><code>vim /etc/locale-gen
(uncomment both en_US lines, save and quit)
locale-gen

Test with `locale -a`
</code></pre>

<h2>set up nginx</h2>

<pre><code>pacman -S nginx
</code></pre>

<p>Use this as /etc/nginx/conf/nginx.conf (edit as appropriate)</p>

<p>NOTE: the 'include /home/<em>/site/</em>;' line pulls in all the sites
defined in all user directories. The idea is to have one user for
each site so that Capistrano can use distinct Cap files with distinct
users, in case we need to do different things.</p>

<pre><code>user http;
worker_processes  6;
#worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
    #                  '$status $body_bytes_sent &quot;$http_referer&quot; '
    #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }

    # THIS LINE ADDS SITE CONFIGURATION FILES within the 'http' block
    include /home/**/nginx.conf;
}
</code></pre>

<h2>configure postfix</h2>

<pre><code> edit /etc/postfix/main.cf
  add

 myhostname = HOSTNAME
</code></pre>

<h2>install &amp; configure monit</h2>

<p>NOTE!!!!! There are a bunch of md5 checksums in the file checks. They are probably
all wrong. You need to manually edit the /etc/monitrc file and check each one
against 'md5sum <path>'</p>

<p>Install using:</p>

<pre><code>add monit group:

  groupadd monit

edit /etc/rc.conf daemon line to add 'monitd' to startup

mkdir /var/monit/ /var/monit/eventq

Edit /etc/monitrc:

NOTE: change all Checksums and HOST names to the correct ones for the system.

  set daemon 300 # check services at 5 minute intervals
      with start delay 240  # wait for services to start before starting to monitor
  set logfile syslog facility log_daemon
  set idfile    /var/monit/.monit.id
  set statefile /var/monit/.monit.state
  set mailserver localhost
  set mail-format { from: root@$HOST }  # FIXME!!!!! replace $HOST with real host name (above)
  set alert $ADMIN_EMAIL                         # receive all alerts

  set eventqueue
    basedir /var/monit/eventq  # set the base directory where events will be stored
    slots 100           # optionally limit the queue size


  set httpd port 2812 and
    use address localhost  # only accept connection from localhost
allow localhost        # allow localhost to connect to the server and
allow admin:monit      # require user 'admin' with password 'monit'
allow @monit           # allow users of group 'monit' to connect (rw)
allow @users readonly  # allow users of group 'users' to connect readonly

  check system $HOST   # FIXME!!!!! - insert system name
    if loadavg (1min) &gt; 4 then alert
    if loadavg (5min) &gt; 2 then alert
    if memory usage &gt; 75% then alert
    if swap usage &gt; 25% then alert
    if cpu usage (user) &gt; 70% then alert
    if cpu usage (system) &gt; 30% then alert
    if cpu usage (wait) &gt; 20% then alert

  # check nginx - cobbled from apache check
  check file nginx_bin with path /usr/sbin/nginx
    if failed md5 checksum and
       expect the sum 3acd86b57f9116d99cf43d3770fd7d44 then stop
    if failed permission 755 then stop
    if failed uid root then stop
    if failed gid root then stop
    alert mike@clove.com on {
          checksum, permission, uid, gid # , unmonitor
      } with the mail-format { subject: &quot;nginx failure&quot; }
    group server

  check process nginx with pidfile /var/run/nginx.pid
    start program = &quot;/etc/rc.d/nginx start&quot; with timeout 60 seconds
    stop program  = &quot;/etc/rc.d/nginx stop&quot;
    if cpu &gt; 60% for 2 cycles then alert
    if cpu &gt; 80% for 5 cycles then restart
    if totalmem &gt; 200.0 MB for 5 cycles then restart
    if children &gt; 250 then restart
    if loadavg(5min) greater than 10 for 8 cycles then stop
    if failed host localhost port 80 protocol http
       and request &quot;/&quot;
       then restart
  # enable if nginx serves SSL
  #  if failed port 443 type tcpssl protocol http
  #     with timeout 15 seconds
  #     then restart
    if 3 restarts within 5 cycles then timeout
    depends on nginx_bin
    group server

  # check postgres - cobbled from apache check
  check file postgres_bin with path /usr/bin/postgres
    if failed md5 checksum and
       expect the sum 13704b8f314a0aa92e7d03557595f2de then stop
    if failed permission 755 then stop
    if failed uid root then stop
    if failed gid root then stop
    alert mike@clove.com on {
          checksum, permission, uid, gid # , unmonitor
      } with the mail-format { subject: &quot;nginx failure&quot; }
    group server

  check process postgres with pidfile /var/lib/postgres/data/postmaster.pid
    start program = &quot;/etc/rc.d/postgresql start&quot; with timeout 5 seconds # with timeout 60 seconds
    stop program  = &quot;/etc/rc.d/postgresql stop&quot;
    if cpu &gt; 60% for 2 cycles then alert
    if cpu &gt; 80% for 5 cycles then restart
    if totalmem &gt; 200.0 MB for 5 cycles then restart
    if children &gt; 250 then restart
    if loadavg(5min) greater than 10 for 8 cycles then stop
    if failed host localhost port 5432 type TCP protocol PGSQL
       then restart
    if 3 restarts within 5 cycles then timeout
    depends on postgres_bin
    group server


  # check postfix - cobbled from apache check
  check file postfix_bin with path /usr/sbin/postfix
    if failed md5 checksum and
       expect the sum 869b5a36e7f2d553197675fec58c3917 then stop
    if failed permission 755 then stop
    if failed uid root then stop
    if failed gid root then stop
    alert mike@clove.com on {
          checksum, permission, uid, gid # , unmonitor
      } with the mail-format { subject: &quot;/usr/sbin/postfix modified &quot; }
    group server

  # check postfix - cobbled from apache check
  check file postmaster_bin with path /usr/bin/postmaster
    if failed md5 checksum and
       expect the sum 13704b8f314a0aa92e7d03557595f2de then stop
    if failed permission 755 then stop
    if failed uid root then stop
    if failed gid root then stop
    alert mike@clove.com on {
          checksum, permission, uid, gid # , unmonitor
      } with the mail-format { subject: &quot;/usr/sbin/postmaster modified &quot; }
    group server

  check process postfix with pidfile /var/spool/postfix/pid/master.pid
    start program = &quot;/etc/rc.d/postfix start&quot; with timeout 5 seconds # with timeout 60 seconds
    stop program  = &quot;/etc/rc.d/postfix stop&quot;
    if cpu &gt; 60% for 2 cycles then alert
    if cpu &gt; 80% for 5 cycles then restart
    if totalmem &gt; 200.0 MB for 5 cycles then restart
    if children &gt; 250 then restart
    if loadavg(5min) greater than 10 for 8 cycles then stop
    if failed host localhost port 25 type TCP protocol SMTP
       then restart
    if 3 restarts within 5 cycles then timeout
    depends on postfix_bin, postmaster_bin
    group server

  # include all site monitrc files
  include /home/**/monitrc
</code></pre>

<p>Access monit via http through an ssh tunnel:</p>

<pre><code>ssh -L 2812:${HOST}:2812 ${ADMIN}@${HOST}
</code></pre>

<h2>install snort</h2>

<p>TBD</p>

<pre><code>pacman -S snort
</code></pre>

<h2>install git</h2>

<p>If you haven't already installed git, do:</p>

<pre><code>pacman -S git
</code></pre>

<p>The only configuration which will be required is on a per-site basis: each
site's userid must be set up on github.com as a </p>

<h2>set up posgresql</h2>

<pre><code>pacman -S postgresql

adduser postgres
mkdir /usr/local/pgsql/data
chown postgres /usr/local/pgsql/data
su - postgres
/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data
/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;
/usr/local/pgsql/bin/createdb test
/usr/local/pgsql/bin/psql test
</code></pre>

<h2>Configure boot</h2>

<p>NOTE: we probably don't need to start postgresql and nginx when using monitd</p>

<p>add iptables ip6tables postgresql nginx monitd to DAEMONS</p>

<pre><code>cp /etc/rc.conf /etc/rc.conf-orig
sed -e '/^DAEMONS/{ s/^/# /
  aDAEMONS=(syslog-ng network iptables ip6tables crond sshd postgresql nginx postfix monitd)
  }' \
/etc/rc.conf-orig &gt;/etc/rc.conf
cat /etc/rc.conf
</code></pre>

<h2>As user '$ADMIN</h2>

<h3>install rvm</h3>

<pre><code>bash &lt; &lt;(curl -s https://rvm.beginrescueend.com/install/rvm)
</code></pre>

<h3>install ruby 1.9.2</h3>

<pre><code>rvm install 1.9.2
(wait)
rvm use 1.9.2 --default

gem install bundler
</code></pre>
