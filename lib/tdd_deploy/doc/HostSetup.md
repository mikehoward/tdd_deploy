# Setup of a Linode Server running Arch Linux

These pseudo-scripts are the actions which are used to configure a remote host
as a web server for one or more Rails based web sites.
They are pseudo-scripts rather than full scripts because some actions are indicated
rather than scripted.

The basic site will look like:

* **ssh** access from a local host (unnamed)
* web service via **nginx** which acts as a reverse proxy for the
**'thin'** ruby web server.
* a local database running **postgresql**
* multiple sites
 * each site runs under it's own user id
 * each site has it's own rvm based ruby installation
 * each site manages it's own 'thin' web servers and directs monit to monitor them
 * each site is installed via Capistrano
* the host run's **monit** - which monitors the health of **nginx**,
**postgresql**, **postfix**, and all the **thin** web servers for all
the sites.
* the host is firewalled using **iptables** and **iptables6**.
* the host runs a minimal set of sesrvices.

These notes detail setting up a server running Arch linux.

(There are a few notes for instructions for Ubuntu, but they are
incomplete.)

    
## Test Driven Host Setup

The tests/hosts directory contains a bunch of tests which run commands
on hosts - either selected hosts, or all hosts defined in the :hosts role
in the Capfile.

The test parameters may be set by defining environment variables.

For Host Provisioning Testing

* HOSTS - list of hosts to run tests on. Default is all hosts defined in the
:hosts role of the Capfile
* HOST\_ADMIN - name of admin user on all hosts (NOT root). Defaults to 'host\_admin'
* LOCAL\_ADMIN - name of admin user on local (maybe development or staging site)
who has the authority to run commands on all hosts. Should be able to ssh into
both HOST\_ADMIN and 'root' on all hosts via public key logins. Defaults to
'local\_admin'
* LOCAL\_ADMIN_EMAIL - email address of admin who should receive notifications
from all hosts - typically from 'monit'. Defaults to 'local\_admin@example.com'


## TDD Installation

The **test** directory includes a set of tests to excercise connectivity to the
host and checks that the basic services are installed and running.



## Shell Variables Used in enclosed Scripts

These variables are used in the pseudo-scripts.

    HOST=my host name
    ADMIN=name of admin user on HOST - not root
    LOCAL_ADMIN=userid of local admin user who has passwordless ssh access
    LOCAL_ADMIN_EMAIL=email address of local administrator who should receive notifications

## set up root ssh access

We need root ssh access for testing the connection and verifying system level
installs are working

    add $LOCAL_ADMIN key to ~root/.ssh/authorized_keys

    edit /etc/ssh/sshd_config
    
    PermitRootLogin yes

    /etc/rc.d/sshd restart  # arch linux
    # service ssh restart     # ubuntu linux

    Test ssh root@hostname to make sure it works, then change
    PermitRootLogin without-password

## Create user $ADMIN

    adduser -G monit $ADMIN

    (fill in as appropriate)

    chmod 711 /home/$ADMIN
a
    sudo su - $ADMIN

    mkdir htdocs
    chgrp nginx htdocs
    chmod 755 htdocs
    chmod g+s htdocs

Add $ADMIN to sudoer's

    vi /etc/sudoers
    (add mike as equivalent to root)


## install packages

As root

    pacman -Su

    pacman -Sy

    pacman -S nginx ruby iptables postgresql postfix monit git

    # yes, we immediately remove ruby. We only install it so that the prerequisites are
    #  available to build rubies using 'rvm'. And, yes, it's cheesy, but it works.
    pacman -R ruby   

## setup for iptables

    pacman -S iptables # pulls in both iptables and ip6tables
    
These configurations only allow HTTP, HTTPS, and SSH traffic.
The do not work if the dbms is on a separate host or if we need
multiple hosts to do load balancing.

We will resolve this when we need it - hopefully that will coincide
with $$$ to hire it done.
    
### iptables

cd /etc/iptables

    cat <<-EOF >iptables.rules
    # Generated by iptables-save v1.4.10 on Fri Jul  8 04:13:58 2011
    *filter
    :INPUT DROP [0:0]
    :FORWARD DROP [0:0]
    :OUTPUT ACCEPT [1676:404831]
    :TCP - [0:0]
    :UDP - [0:0]
    -A INPUT -i lo -j ACCEPT 
    -A INPUT -m conntrack --ctstate INVALID -j DROP 
    -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 
    -A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT 
    -A INPUT -p udp -m conntrack --ctstate NEW -j UDP 
    -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP 
    -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable 
    -A INPUT -p tcp -j REJECT --reject-with tcp-reset 
    -A INPUT -j REJECT --reject-with icmp-proto-unreachable 
    -A TCP -p tcp -m tcp --dport 22 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 80 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 443 -j ACCEPT 
    -A UDP -p udp -m udp --dport 22 -j ACCEPT 
    -A UDP -p udp -m udp --dport 80 -j ACCEPT 
    -A UDP -p udp -m udp --dport 443 -j ACCEPT 
    COMMIT
    # Completed on Fri Jul  8 04:13:58 2011
    EOF

    /etc/rc.d/iptables restart
    /etc/rc.d/iptables save

###  ip6tables

ip6tables has similar, but slightly different syntax. I don't expect
any IPV6 traffic, but there is no reason not to respond and even more
reason not to leave holes open.

cd /etc/iptables

    cat <<-EOF >ip6tables.rules
    # Generated by iptables-save v1.4.10 on Fri Jul  8 04:13:58 2011
    *filter
    :INPUT DROP [0:0]
    :FORWARD DROP [0:0]
    :OUTPUT ACCEPT [1676:404831]
    :TCP - [0:0]
    :UDP - [0:0]
    -A INPUT -i lo -j ACCEPT 
    -A INPUT -m conntrack --ctstate INVALID -j DROP 
    -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 
    # echo request
    # this is the ipv4 version
    # -A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT 
    -A INPUT -p icmpv6 -m icmp6 --icmpv6-type 128 -m conntrack --ctstate NEW -j ACCEPT 
    -A INPUT -p udp -m conntrack --ctstate NEW -j UDP 
    -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP 
    -A INPUT -p udp -j REJECT --reject-with icmp6-port-unreachable 
    -A INPUT -p tcp -j REJECT --reject-with tcp-reset 
    -A INPUT -j REJECT --reject-with adm-prohibited
    -A TCP -p tcp -m tcp --dport 22 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 80 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 443 -j ACCEPT 
    -A UDP -p udp -m udp --dport 22 -j ACCEPT 
    -A UDP -p udp -m udp --dport 80 -j ACCEPT 
    -A UDP -p udp -m udp --dport 443 -j ACCEPT 
    COMMIT
    # Completed on Fri Jul  8 04:13:58 2011

## Enable en_US locale

run `locale -a`

if it works, then go to nginx

if not, then

    vim /etc/locale-gen
    (uncomment both en_US lines, save and quit)
    locale-gen
    
    Test with `locale -a`

## set up nginx

    pacman -S nginx

Use this as /etc/nginx/conf/nginx.conf (edit as appropriate)

NOTE: the 'include /home/*/site/nginx.conf;' line pulls in all the sites
defined in all user directories. The idea is to have one user for
each site so that Capistrano can use distinct Cap files with distinct
users, in case we need to do different things.

      user http;
      worker_processes  6;
      #worker_processes  1;

      #error_log  logs/error.log;
      #error_log  logs/error.log  notice;
      #error_log  logs/error.log  info;

      #pid        logs/nginx.pid;


      events {
          worker_connections  1024;
      }


      http {
          include       mime.types;
          default_type  application/octet-stream;

          #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
          #                  '$status $body_bytes_sent "$http_referer" '
          #                  '"$http_user_agent" "$http_x_forwarded_for"';

          #access_log  logs/access.log  main;

          sendfile        on;
          #tcp_nopush     on;

          #keepalive_timeout  0;
          keepalive_timeout  65;

          #gzip  on;

          server {
              listen       80;
              server_name  localhost;

              #charset koi8-r;

              #access_log  logs/host.access.log  main;

              location / {
                  root   html;
                  index  index.html index.htm;
              }

              #error_page  404              /404.html;

              # redirect server error pages to the static page /50x.html
              #
              error_page   500 502 503 504  /50x.html;
              location = /50x.html {
                  root   html;
              }

          }

          # THIS LINE ADDS SITE CONFIGURATION FILES
          include /home/*/site/nginx.conf;
      }

## configure postfix

     edit /etc/postfix/main.cf
      add
 
	 myhostname = HOSTNAME

## install & configure monit

NOTE!!!!! There are a bunch of md5 checksums in the file checks. They are probably
all wrong. You need to manually edit the /etc/monitrc file and check each one
against 'md5sum <path>'

Install using:

    add monit group:

    groupadd monit

    edit /etc/rc.conf daemon line to add 'monitd' to startup
    
    mkdir /var/monit/ /var/monit/eventq
    
Copy, edit and run this script to create a monitrc file. It creates a file file named `monitrc-new`
in your local directory. Look it over and copy it into /etc/monitrc, owned by root, group root,
and perms 0400.

Check over the output and modify the script as needed.
 
    ------------------------start here--------------------------
      #! /bin/bash
      
      HOST=real-host-name
      HOST_ADMIN_EMAIL=user-who-should-get-monit-alerts
      MONIT_ADMIN=monit-admin-userid
      SECRET_PASSWORD=password-which-must-be-given-to-access-monit-http-server-output
      
      cat <<-EOF >monitrc-new
      set daemon 300 # check services at 5 minute intervals
        with start delay 240  # wait for services to start before starting to monitor
      set logfile syslog facility log_daemon
      set idfile    /var/monit/.monit.id
      set statefile /var/monit/.monit.state
      set mailserver localhost
      set mail-format { from: root@${HOST} }
      set alert ${HOST_ADMIN_EMAIL} # receive all alerts

      set eventqueue
      basedir /var/monit/eventq  # set the base directory where events will be stored
      slots 100           # optionally limit the queue size

      # this sets up monit's http server to run on local host. I run a tunnel through an ssh
      #  session to access it
      set httpd port 2812 and
      use address localhost  # only accept connection from localhost
      allow localhost        # allow localhost to connect to the server and
      allow ${MONIT_ADMIN}:${SECRET_PASSWORD}      # require user 'admin' with password 'monit'
      allow @monit           # allow users of group 'monit' to connect (rw)
      allow @users readonly  # allow users of group 'users' to connect readonly

      check system ${HOST}   # FIXME!!!!! - insert system name
      if loadavg (1min) > 4 then alert
      if loadavg (5min) > 2 then alert
      if memory usage > 75% then alert
      if swap usage > 25% then alert
      if cpu usage (user) > 70% then alert
      if cpu usage (system) > 30% then alert
      if cpu usage (wait) > 20% then alert

      # check nginx - cobbled from apache check
      check file nginx_bin with path /usr/sbin/nginx
      if failed md5 checksum and
         expect the sum `md5sum /usr/sbin/nginx | awk '{print $1}'` then stop
      if failed permission 755 then stop
      if failed uid root then stop
      if failed gid root then stop
      alert mike@clove.com on {
            checksum, permission, uid, gid # , unmonitor
        } with the mail-format { subject: "nginx failure" }
      group server


      check process nginx with pidfile /var/run/nginx.pid
      start program = "/etc/rc.d/nginx start" with timeout 60 seconds
      stop program  = "/etc/rc.d/nginx stop"
      if cpu > 60% for 2 cycles then alert
      if cpu > 80% for 5 cycles then restart
      if totalmem > 200.0 MB for 5 cycles then restart
      if children > 250 then restart
      if loadavg(5min) greater than 10 for 8 cycles then stop
      if failed host localhost port 80 then restart
      # enable if nginx serves SSL
      #  if failed port 443 type tcpssl protocol http
      #     with timeout 15 seconds
      #     then restart
      if 3 restarts within 5 cycles then timeout
      depends on nginx_bin
      group server

      # check postgres - cobbled from apache check
      check file postgres_bin with path /usr/bin/postgres
      if failed md5 checksum and
         expect the sum `md5sum /usr/bin/postgres | awk '{print $1}'` then stop
      if failed permission 755 then stop
      if failed uid root then stop
      if failed gid root then stop
      alert mike@clove.com on {
            checksum, permission, uid, gid # , unmonitor
        } with the mail-format { subject: "nginx failure" }
      group server

      check process postgres with pidfile /var/lib/postgres/data/postmaster.pid
      start program = "/etc/rc.d/postgresql start" with timeout 5 seconds # with timeout 60 seconds
      stop program  = "/etc/rc.d/postgresql stop"
      if cpu > 60% for 2 cycles then alert
      if cpu > 80% for 5 cycles then restart
      if totalmem > 200.0 MB for 5 cycles then restart
      if children > 250 then restart
      if loadavg(5min) greater than 10 for 8 cycles then stop
      if failed host localhost port 5432 type TCP protocol PGSQL
         then restart
      if 3 restarts within 5 cycles then timeout
      depends on postgres_bin
      group server


      # check postfix - cobbled from apache check
      check file postfix_bin with path /usr/sbin/postfix
      if failed md5 checksum and
         expect the sum `md5sum /usr/sbin/postfix | awk '{print $1}'` then stop
      if failed permission 755 then stop
      if failed uid root then stop
      if failed gid root then stop
      alert mike@clove.com on {
            checksum, permission, uid, gid # , unmonitor
        } with the mail-format { subject: "/usr/sbin/postfix modified " }
      group server

      # check postfix - cobbled from apache check
      check file postmaster_bin with path /usr/bin/postmaster
      if failed md5 checksum and
         expect the sum `md5sum /usr/bin/postmaster | awk '{print $1}'` then stop
      if failed permission 755 then stop
      if failed uid root then stop
      if failed gid root then stop
      alert mike@clove.com on {
            checksum, permission, uid, gid # , unmonitor
        } with the mail-format { subject: "/usr/sbin/postmaster modified " }
      group server

      check process postfix with pidfile /var/spool/postfix/pid/master.pid
      start program = "/etc/rc.d/postfix start" with timeout 5 seconds # with timeout 60 seconds
      stop program  = "/etc/rc.d/postfix stop"
      if cpu > 60% for 2 cycles then alert
      if cpu > 80% for 5 cycles then restart
      if totalmem > 200.0 MB for 5 cycles then restart
      if children > 250 then restart
      if loadavg(5min) greater than 10 for 8 cycles then stop
      if failed host localhost port 25 type TCP protocol SMTP
         then restart
      if 3 restarts within 5 cycles then timeout
      depends on postfix_bin, postmaster_bin
      group server

      # include all site monitrc files
      include /home/*/site/monitrc
      EOF
    ------------------------end here--------------------------

Access monit via http through an ssh tunnel:

    ssh -L 2812:${HOST}:2812 ${ADMIN}@${HOST}
 

## install snort

TBD

    pacman -S snort

## install git

If you haven't already installed git, do:

    pacman -S git

The only configuration which will be required is on a per-site basis: each
site's userid must be set up on github.com as a 

## set up posgresql

    pacman -S postgresql

    adduser postgres
    mkdir /usr/local/pgsql/data
    chown postgres /usr/local/pgsql/data
    su - postgres
    /usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data
    /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data >logfile 2>&1 &
    /usr/local/pgsql/bin/createdb test
    /usr/local/pgsql/bin/psql test

## Configure boot

add iptables ip6tables postgresql nginx monitd to DAEMONS
    
    cp /etc/rc.conf /etc/rc.conf-orig
    sed -e '/^DAEMONS/{ s/^/# /
      aDAEMONS=(syslog-ng network iptables ip6tables crond sshd postgresql nginx postfix monitd)
      }' \
    /etc/rc.conf-orig >/etc/rc.conf
    cat /etc/rc.conf
