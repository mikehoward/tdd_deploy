# Setup of a Linode Server running Arch Linux

These pseudo-scripts are the actions which are used to configure a remote host
as a web server for one or more Rails based web sites.
They are pseudo-scripts rather than full scripts because some actions are indicated
rather than scripted.

The basic site will look like:

* **ssh** access from a local host (unnamed)
* web service via **nginx** which acts as a reverse proxy for the
**'thin'** ruby web server.
* a local database running **postgresql**
* multiple sites
 * each site runs under it's own user id
 * each site has it's own rvm based ruby installation
 * each site manages it's own 'thin' web servers and directs monit to monitor them
 * each site is installed via Capistrano
* the host run's **monit** - which monitors the health of **nginx**,
**postgresql**, **postfix**, and all the **thin** web servers for all
the sites.
* the host is firewalled using **iptables** and **iptables6**.
* the host runs a minimal set of sesrvices.

These notes detail setting up a server running Arch linux.

(There are a few notes for instructions for Ubuntu, but they are
incomplete.)

    
## Test Driven Host Setup

The tests/hosts directory contains a bunch of tests which run commands
on hosts - either selected hosts, or all hosts defined in the :hosts role
in the Capfile.

The test parameters may be set by defining environment variables.

For Host Provisioning Testing

* HOSTS - list of hosts to run tests on. Default is all hosts defined in the
:hosts role of the Capfile
* HOST\_ADMIN - name of admin user on all hosts (NOT root). Defaults to 'host\_admin'
* LOCAL\_ADMIN - name of admin user on local (maybe development or staging site)
who has the authority to run commands on all hosts. Should be able to ssh into
both HOST\_ADMIN and 'root' on all hosts via public key logins. Defaults to
'local\_admin'
* LOCAL\_ADMIN_EMAIL - email address of admin who should receive notifications
from all hosts - typically from 'monit'. Defaults to 'local\_admin@example.com'


## TDD Installation

The **test** directory includes a set of tests to excercise connectivity to the
host and checks that the basic services are installed and running.



## Shell Variables Used in enclosed Scripts

These variables are used in the pseudo-scripts.

    HOST=my host name
    ADMIN=name of admin user on HOST - not root
    LOCAL_ADMIN=userid of local admin user who has passwordless ssh access
    LOCAL_ADMIN_EMAIL=email address of local administrator who should receive notifications

## set up root ssh access

We need root ssh access for testing the connection and verifying system level
installs are working

    add $LOCAL_ADMIN key to ~root/.ssh/authorized_keys

    edit /etc/ssh/sshd_config
    
    PermitRootLogin yes

    /etc/rc.d/sshd restart  # arch linux
    # service ssh restart     # ubuntu linux

    Test ssh root@hostname to make sure it works, then change
    PermitRootLogin without-password

## Create user $ADMIN

    adduser -G monit $ADMIN

    (fill in as appropriate)

    chmod 711 /home/$ADMIN
a
    sudo su - $ADMIN

    mkdir htdocs
    chgrp nginx htdocs
    chmod 755 htdocs
    chmod g+s htdocs

Add $ADMIN to sudoer's

    vi /etc/sudoers
    (add mike as equivalent to root)


## install packages

As root

    pacman -Su

    pacman -Sy

    pacman -S nginx ruby iptables postgresql postfix monit git

    # yes, we immediately remove ruby. We only install it so that the prerequisites are
    #  available to build rubies using 'rvm'. And, yes, it's cheesy, but it works.
    pacman -R ruby   

## setup for iptables

    pacman -S iptables # pulls in both iptables and ip6tables
    
These configurations only allow HTTP, HTTPS, and SSH traffic.
The do not work if the dbms is on a separate host or if we need
multiple hosts to do load balancing.

We will resolve this when we need it - hopefully that will coincide
with $$$ to hire it done.
    
### iptables

cd /etc/iptables

    cat <<-EOF >iptables.rules
    # Generated by iptables-save v1.4.10 on Fri Jul  8 04:13:58 2011
    *filter
    :INPUT DROP [0:0]
    :FORWARD DROP [0:0]
    :OUTPUT ACCEPT [1676:404831]
    :TCP - [0:0]
    :UDP - [0:0]
    -A INPUT -i lo -j ACCEPT 
    -A INPUT -m conntrack --ctstate INVALID -j DROP 
    -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 
    -A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT 
    -A INPUT -p udp -m conntrack --ctstate NEW -j UDP 
    -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP 
    -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable 
    -A INPUT -p tcp -j REJECT --reject-with tcp-reset 
    -A INPUT -j REJECT --reject-with icmp-proto-unreachable 
    -A TCP -p tcp -m tcp --dport 22 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 80 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 443 -j ACCEPT 
    -A UDP -p udp -m udp --dport 22 -j ACCEPT 
    -A UDP -p udp -m udp --dport 80 -j ACCEPT 
    -A UDP -p udp -m udp --dport 443 -j ACCEPT 
    COMMIT
    # Completed on Fri Jul  8 04:13:58 2011
    EOF

    /etc/rc.d/iptables restart
    /etc/rc.d/iptables save

###  ip6tables

ip6tables has similar, but slightly different syntax. I don't expect
any IPV6 traffic, but there is no reason not to respond and even more
reason not to leave holes open.

cd /etc/iptables

    cat <<-EOF >ip6tables.rules
    # Generated by iptables-save v1.4.10 on Fri Jul  8 04:13:58 2011
    *filter
    :INPUT DROP [0:0]
    :FORWARD DROP [0:0]
    :OUTPUT ACCEPT [1676:404831]
    :TCP - [0:0]
    :UDP - [0:0]
    -A INPUT -i lo -j ACCEPT 
    -A INPUT -m conntrack --ctstate INVALID -j DROP 
    -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 
    # echo request
    # this is the ipv4 version
    # -A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT 
    -A INPUT -p icmpv6 -m icmp6 --icmpv6-type 128 -m conntrack --ctstate NEW -j ACCEPT 
    -A INPUT -p udp -m conntrack --ctstate NEW -j UDP 
    -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP 
    -A INPUT -p udp -j REJECT --reject-with icmp6-port-unreachable 
    -A INPUT -p tcp -j REJECT --reject-with tcp-reset 
    -A INPUT -j REJECT --reject-with adm-prohibited
    -A TCP -p tcp -m tcp --dport 22 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 80 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 443 -j ACCEPT 
    -A UDP -p udp -m udp --dport 22 -j ACCEPT 
    -A UDP -p udp -m udp --dport 80 -j ACCEPT 
    -A UDP -p udp -m udp --dport 443 -j ACCEPT 
    COMMIT
    # Completed on Fri Jul  8 04:13:58 2011

## Enable en_US locale

run `locale -a`

if it works, then go to nginx

if not, then

    vim /etc/locale-gen
    (uncomment both en_US lines, save and quit)
    locale-gen
    
    Test with `locale -a`

## set up nginx

    pacman -S nginx

Use this as /etc/nginx/conf/nginx.conf (edit as appropriate)

NOTE: the 'include /home/*/site/*;' line pulls in all the sites
defined in all user directories. The idea is to have one user for
each site so that Capistrano can use distinct Cap files with distinct
users, in case we need to do different things.

    user http;
    worker_processes  6;
    #worker_processes  1;

    #error_log  logs/error.log;
    #error_log  logs/error.log  notice;
    #error_log  logs/error.log  info;

    #pid        logs/nginx.pid;


    events {
        worker_connections  1024;
    }


    http {
        include       mime.types;
        default_type  application/octet-stream;

        #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
        #                  '$status $body_bytes_sent "$http_referer" '
        #                  '"$http_user_agent" "$http_x_forwarded_for"';

        #access_log  logs/access.log  main;

        sendfile        on;
        #tcp_nopush     on;

        #keepalive_timeout  0;
        keepalive_timeout  65;

        #gzip  on;

        server {
            listen       80;
            server_name  localhost;

            #charset koi8-r;

            #access_log  logs/host.access.log  main;

            location / {
                root   html;
                index  index.html index.htm;
            }

            #error_page  404              /404.html;

            # redirect server error pages to the static page /50x.html
            #
            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }

        }

        # THIS LINE ADDS SITE CONFIGURATION FILES
        include /home/*/site/*;
    }

## configure postfix

     edit /etc/postfix/main.cf
      add
 
	 myhostname = HOSTNAME

## install & configure monit

NOTE!!!!! There are a bunch of md5 checksums in the file checks. They are probably
all wrong. You need to manually edit the /etc/monitrc file and check each one
against 'md5sum <path>'

Install using:

    add monit group:

      groupadd monit

    edit /etc/rc.conf daemon line to add 'monitd' to startup
    
    mkdir /var/monit/ /var/monit/eventq
    
    Edit /etc/monitrc:

    NOTE: change all Checksums and HOST names to the correct ones for the system.
    
      set daemon 300 # check services at 5 minute intervals
          with start delay 240  # wait for services to start before starting to monitor
      set logfile syslog facility log_daemon
      set idfile    /var/monit/.monit.id
      set statefile /var/monit/.monit.state
      set mailserver localhost
      set mail-format { from: root@$HOST }  # FIXME!!!!! replace $HOST with real host name (above)
      set alert $ADMIN_EMAIL                         # receive all alerts

      set eventqueue
        basedir /var/monit/eventq  # set the base directory where events will be stored
        slots 100           # optionally limit the queue size


      set httpd port 2812 and
        use address localhost  # only accept connection from localhost
	allow localhost        # allow localhost to connect to the server and
	allow admin:monit      # require user 'admin' with password 'monit'
	allow @monit           # allow users of group 'monit' to connect (rw)
	allow @users readonly  # allow users of group 'users' to connect readonly

      check system $HOST   # FIXME!!!!! - insert system name
        if loadavg (1min) > 4 then alert
        if loadavg (5min) > 2 then alert
        if memory usage > 75% then alert
        if swap usage > 25% then alert
        if cpu usage (user) > 70% then alert
        if cpu usage (system) > 30% then alert
        if cpu usage (wait) > 20% then alert

      # check nginx - cobbled from apache check
      check file nginx_bin with path /usr/sbin/nginx
        if failed md5 checksum and
           expect the sum 3acd86b57f9116d99cf43d3770fd7d44 then stop
        if failed permission 755 then stop
        if failed uid root then stop
        if failed gid root then stop
        alert mike@clove.com on {
              checksum, permission, uid, gid # , unmonitor
          } with the mail-format { subject: "nginx failure" }
        group server
      
      check process nginx with pidfile /var/run/nginx.pid
        start program = "/etc/rc.d/nginx start" with timeout 60 seconds
        stop program  = "/etc/rc.d/nginx stop"
        if cpu > 60% for 2 cycles then alert
        if cpu > 80% for 5 cycles then restart
        if totalmem > 200.0 MB for 5 cycles then restart
        if children > 250 then restart
        if loadavg(5min) greater than 10 for 8 cycles then stop
        if failed host localhost port 80 protocol http
           and request "/"
           then restart
      # enable if nginx serves SSL
      #  if failed port 443 type tcpssl protocol http
      #     with timeout 15 seconds
      #     then restart
        if 3 restarts within 5 cycles then timeout
        depends on nginx_bin
        group server
      
      # check postgres - cobbled from apache check
      check file postgres_bin with path /usr/bin/postgres
        if failed md5 checksum and
           expect the sum 13704b8f314a0aa92e7d03557595f2de then stop
        if failed permission 755 then stop
        if failed uid root then stop
        if failed gid root then stop
        alert mike@clove.com on {
              checksum, permission, uid, gid # , unmonitor
          } with the mail-format { subject: "nginx failure" }
        group server
      
      check process postgres with pidfile /var/lib/postgres/data/postmaster.pid
        start program = "/etc/rc.d/postgresql start" with timeout 5 seconds # with timeout 60 seconds
        stop program  = "/etc/rc.d/postgresql stop"
        if cpu > 60% for 2 cycles then alert
        if cpu > 80% for 5 cycles then restart
        if totalmem > 200.0 MB for 5 cycles then restart
        if children > 250 then restart
        if loadavg(5min) greater than 10 for 8 cycles then stop
        if failed host localhost port 5432 type TCP protocol PGSQL
           then restart
        if 3 restarts within 5 cycles then timeout
        depends on postgres_bin
        group server
      
      
      # check postfix - cobbled from apache check
      check file postfix_bin with path /usr/sbin/postfix
        if failed md5 checksum and
           expect the sum 869b5a36e7f2d553197675fec58c3917 then stop
        if failed permission 755 then stop
        if failed uid root then stop
        if failed gid root then stop
        alert mike@clove.com on {
              checksum, permission, uid, gid # , unmonitor
          } with the mail-format { subject: "/usr/sbin/postfix modified " }
        group server
      
      # check postfix - cobbled from apache check
      check file postmaster_bin with path /usr/bin/postmaster
        if failed md5 checksum and
           expect the sum 13704b8f314a0aa92e7d03557595f2de then stop
        if failed permission 755 then stop
        if failed uid root then stop
        if failed gid root then stop
        alert mike@clove.com on {
              checksum, permission, uid, gid # , unmonitor
          } with the mail-format { subject: "/usr/sbin/postmaster modified " }
        group server
      
      check process postfix with pidfile /var/spool/postfix/pid/master.pid
        start program = "/etc/rc.d/postfix start" with timeout 5 seconds # with timeout 60 seconds
        stop program  = "/etc/rc.d/postfix stop"
        if cpu > 60% for 2 cycles then alert
        if cpu > 80% for 5 cycles then restart
        if totalmem > 200.0 MB for 5 cycles then restart
        if children > 250 then restart
        if loadavg(5min) greater than 10 for 8 cycles then stop
        if failed host localhost port 25 type TCP protocol SMTP
           then restart
        if 3 restarts within 5 cycles then timeout
        depends on postfix_bin, postmaster_bin
        group server


Access monit via http through an ssh tunnel:

    ssh -L 2812:${HOST}:2812 ${ADMIN}@${HOST}
 

## install snort

TBD

    pacman -S snort

## install git

If you haven't already installed git, do:

    pacman -S git

The only configuration which will be required is on a per-site basis: each
site's userid must be set up on github.com as a 

## set up posgresql

    pacman -S postgresql

    adduser postgres
    mkdir /usr/local/pgsql/data
    chown postgres /usr/local/pgsql/data
    su - postgres
    /usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data
    /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data >logfile 2>&1 &
    /usr/local/pgsql/bin/createdb test
    /usr/local/pgsql/bin/psql test

## Configure boot

NOTE: we probably don't need to start postgresql and nginx when using monitd

add iptables ip6tables postgresql nginx monitd to DAEMONS
    
    cp /etc/rc.conf /etc/rc.conf-orig
    sed -e '/^DAEMONS/{ s/^/# /
      aDAEMONS=(syslog-ng network iptables ip6tables crond sshd postgresql nginx postfix monitd)
      }' \
    /etc/rc.conf-orig >/etc/rc.conf
    cat /etc/rc.conf
    
## As user '$ADMIN

### install rvm

    bash < <(curl -s https://rvm.beginrescueend.com/install/rvm)

### install ruby 1.9.2

    rvm install 1.9.2
    (wait)
    rvm use 1.9.2 --default
    
    gem install bundler
