# Setup of a Linode Server running Arch Linux

These notes detail setting up a server running Arch linux.

There are a few notes for instructions for Ubuntu, but they are
incomplete.

## set up ssh access

    add user key to ~root/.ssh/authorized_keys

    edit /etc/ssh/sshd_config
    
    PermitRootLogin yes

    /etc/rc.d/sshd restart  # arch linux
    # service ssh restart     # ubuntu linux

    Test ssh root@hostname to make sure it works, then change
    PermitRootLogin without-password


## install packages

As root

    pacman -Su

    pacman -Sy

    pacman -S nginx ruby iptables postgresql postfix

    # yes, we immediately remove ruby. We only install it so that the prerequisites are
    #  available to build rubies using 'rvm'. And, yes, it's cheesy, but it works.
    pacman -R ruby   

## setup for iptables

    pacman -S iptables # pulls in both iptables and ip6tables
    
These configurations only allow HTTP, HTTPS, and SSH traffic.
The do not work if the dbms is on a separate host or if we need
multiple hosts to do load balancing.

We will resolve this when we need it - hopefully that will coincide
with $$$ to hire it done.
    
### iptables

cd /etc/iptables

    cat <<-EOF >iptables.rules
    # Generated by iptables-save v1.4.10 on Fri Jul  8 04:13:58 2011
    *filter
    :INPUT DROP [0:0]
    :FORWARD DROP [0:0]
    :OUTPUT ACCEPT [1676:404831]
    :TCP - [0:0]
    :UDP - [0:0]
    -A INPUT -i lo -j ACCEPT 
    -A INPUT -m conntrack --ctstate INVALID -j DROP 
    -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 
    -A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT 
    -A INPUT -p udp -m conntrack --ctstate NEW -j UDP 
    -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP 
    -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable 
    -A INPUT -p tcp -j REJECT --reject-with tcp-reset 
    -A INPUT -j REJECT --reject-with icmp-proto-unreachable 
    -A TCP -p tcp -m tcp --dport 22 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 80 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 443 -j ACCEPT 
    -A UDP -p udp -m udp --dport 22 -j ACCEPT 
    -A UDP -p udp -m udp --dport 80 -j ACCEPT 
    -A UDP -p udp -m udp --dport 443 -j ACCEPT 
    COMMIT
    # Completed on Fri Jul  8 04:13:58 2011
    EOF

    /etc/rc.d/iptables restart
    /etc/rc.d/iptables save

###  ip6tables

ip6tables has similar, but slightly different syntax. I don't expect
any IPV6 traffic, but there is no reason not to respond and even more
reason not to leave holes open.

cd /etc/iptables

    cat <<-EOF >ip6tables.rules
    # Generated by iptables-save v1.4.10 on Fri Jul  8 04:13:58 2011
    *filter
    :INPUT DROP [0:0]
    :FORWARD DROP [0:0]
    :OUTPUT ACCEPT [1676:404831]
    :TCP - [0:0]
    :UDP - [0:0]
    -A INPUT -i lo -j ACCEPT 
    -A INPUT -m conntrack --ctstate INVALID -j DROP 
    -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 
    # echo request
    # this is the ipv4 version
    # -A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT 
    -A INPUT -p icmpv6 -m icmp6 --icmpv6-type 128 -m conntrack --ctstate NEW -j ACCEPT 
    -A INPUT -p udp -m conntrack --ctstate NEW -j UDP 
    -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP 
    -A INPUT -p udp -j REJECT --reject-with icmp6-port-unreachable 
    -A INPUT -p tcp -j REJECT --reject-with tcp-reset 
    -A INPUT -j REJECT --reject-with adm-prohibited
    -A TCP -p tcp -m tcp --dport 22 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 80 -j ACCEPT 
    -A TCP -p tcp -m tcp --dport 443 -j ACCEPT 
    -A UDP -p udp -m udp --dport 22 -j ACCEPT 
    -A UDP -p udp -m udp --dport 80 -j ACCEPT 
    -A UDP -p udp -m udp --dport 443 -j ACCEPT 
    COMMIT
    # Completed on Fri Jul  8 04:13:58 2011

## Enable en_US locale

run `locale -a`

if it works, then go to nginx

if not, then

    vim /etc/locale-gen
    (uncomment both en_US lines, save and quit)
    locale-gen
    
    Test with `locale -a`

## set up nginx

    pacman -S nginx

Use this as /etc/nginx/conf/nginx.conf (edit as appropriate)

NOTE: the 'include /home/*/site/*;' line pulls in all the sites
defined in all user directories. The idea is to have one user for
each site so that Capistrano can use distinct Cap files with distinct
users, in case we need to do different things.

    user http;
    worker_processes  6;
    #worker_processes  1;

    #error_log  logs/error.log;
    #error_log  logs/error.log  notice;
    #error_log  logs/error.log  info;

    #pid        logs/nginx.pid;


    events {
        worker_connections  1024;
    }


    http {
        include       mime.types;
        default_type  application/octet-stream;

        #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
        #                  '$status $body_bytes_sent "$http_referer" '
        #                  '"$http_user_agent" "$http_x_forwarded_for"';

        #access_log  logs/access.log  main;

        sendfile        on;
        #tcp_nopush     on;

        #keepalive_timeout  0;
        keepalive_timeout  65;

        #gzip  on;

        server {
            listen       80;
            server_name  localhost;

            #charset koi8-r;

            #access_log  logs/host.access.log  main;

            location / {
                root   html;
                index  index.html index.htm;
            }

            #error_page  404              /404.html;

            # redirect server error pages to the static page /50x.html
            #
            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }

        }

        # THIS LINE ADDS SITE CONFIGURATION FILES
        include /home/*/site/*;
    }

## configure postfix

     edit /etc/postfix/main.cf
      add
 
         process_id_directory = /var/run/postfix.pid
	 
	 myhostname = HOSTNAME

## install & configure monit

Install using:

    pacman -S monit
    
    add monit group:

      groupadd monit

    edit /etc/rc.conf daemon line to add 'monitd' to startup
    
    mkdir /var/monit/ /var/monit/eventq
    
    Edit /etc/monitrc:

    NOTE: change all Checksums and HOST names to the correct ones for the system.
    
      set daemon 300 # check services at 5 minute intervals
          with start delay 240  # wait for services to start before starting to monitor
      set logfile syslog facility log_daemon
      set idfile    /var/monit/.monit.id
      set statefile /var/monit/.monit.state
      set mailserver localhost
      set mail-format { from: root@HOST }  # FIXME!!!!! replace HOST with real host name
      set alert mike@clove.com                         # receive all alerts

      set eventqueue
        basedir /var/monit/eventq  # set the base directory where events will be stored
        slots 100           # optionally limit the queue size


      set httpd port 2812 and
        use address localhost  # only accept connection from localhost
	allow localhost        # allow localhost to connect to the server and
	allow admin:monit      # require user 'admin' with password 'monit'
	allow @monit           # allow users of group 'monit' to connect (rw)
	allow @users readonly  # allow users of group 'users' to connect readonly

      check system arch   # FIXME!!!!! - insert system name
        if loadavg (1min) > 4 then alert
        if loadavg (5min) > 2 then alert
        if memory usage > 75% then alert
        if swap usage > 25% then alert
        if cpu usage (user) > 70% then alert
        if cpu usage (system) > 30% then alert
        if cpu usage (wait) > 20% then alert

      # check nginx - cobbled from apache check
      check file nginx_bin with path /usr/sbin/nginx
        if failed md5 checksum and
           expect the sum 3acd86b57f9116d99cf43d3770fd7d44 then stop
        if failed permission 755 then stop
        if failed uid root then stop
        if failed gid root then stop
        alert mike@clove.com on {
              checksum, permission, uid, gid # , unmonitor
          } with the mail-format { subject: "nginx failure" }
        group server
      
      check process nginx with pidfile /var/run/nginx.pid
        start program = "/etc/rc.d/nginx start" with timeout 60 seconds
        stop program  = "/etc/rc.d/nginx stop"
        if cpu > 60% for 2 cycles then alert
        if cpu > 80% for 5 cycles then restart
        if totalmem > 200.0 MB for 5 cycles then restart
        if children > 250 then restart
        if loadavg(5min) greater than 10 for 8 cycles then stop
        if failed host localhost port 80 protocol http
           and request "/"
           then restart
      # enable if nginx serves SSL
      #  if failed port 443 type tcpssl protocol http
      #     with timeout 15 seconds
      #     then restart
        if 3 restarts within 5 cycles then timeout
        depends on nginx_bin
        group server
      
      # check postgres - cobbled from apache check
      check file postgres_bin with path /usr/bin/postgres
        if failed md5 checksum and
           expect the sum 13704b8f314a0aa92e7d03557595f2de then stop
        if failed permission 755 then stop
        if failed uid root then stop
        if failed gid root then stop
        alert mike@clove.com on {
              checksum, permission, uid, gid # , unmonitor
          } with the mail-format { subject: "nginx failure" }
        group server
      
      check process postgres with pidfile /var/lib/postgres/data/postmaster.pid
        start program = "/etc/rc.d/postgresql start" with timeout 5 seconds # with timeout 60 seconds
        stop program  = "/etc/rc.d/postgresql stop"
        if cpu > 60% for 2 cycles then alert
        if cpu > 80% for 5 cycles then restart
        if totalmem > 200.0 MB for 5 cycles then restart
        if children > 250 then restart
        if loadavg(5min) greater than 10 for 8 cycles then stop
        if failed host localhost port 5432 type TCP protocol PGSQL
           then restart
        if 3 restarts within 5 cycles then timeout
        depends on postgres_bin
        group server
      
      
      # check postfix - cobbled from apache check
      check file postfix_bin with path /usr/sbin/postfix
        if failed md5 checksum and
           expect the sum 869b5a36e7f2d553197675fec58c3917 then stop
        if failed permission 755 then stop
        if failed uid root then stop
        if failed gid root then stop
        alert mike@clove.com on {
              checksum, permission, uid, gid # , unmonitor
          } with the mail-format { subject: "/usr/sbin/postfix modified " }
        group server
      
      # check postfix - cobbled from apache check
      check file postmaster_bin with path /usr/sbin/postmaster
        if failed md5 checksum and
           expect the sum 13704b8f314a0aa92e7d03557595f2de then stop
        if failed permission 755 then stop
        if failed uid root then stop
        if failed gid root then stop
        alert mike@clove.com on {
              checksum, permission, uid, gid # , unmonitor
          } with the mail-format { subject: "/usr/sbin/postmaster modified " }
        group server
      
      check process postfix with pidfile /var/run/postmaster.pid
        start program = "/etc/rc.d/postfix start" with timeout 5 seconds # with timeout 60 seconds
        stop program  = "/etc/rc.d/postfix stop"
        if cpu > 60% for 2 cycles then alert
        if cpu > 80% for 5 cycles then restart
        if totalmem > 200.0 MB for 5 cycles then restart
        if children > 250 then restart
        if loadavg(5min) greater than 10 for 8 cycles then stop
        if failed host localhost port 25 type TCP protocol SMTP
           then restart
        if 3 restarts within 5 cycles then timeout
        depends on postfix_bin, postmaster_bin
        group server


Access monit via http through an ssh tunnel:

    ssh -L 2812:<host>:2812 mike@<host>
 

## install snort

TBD

    pacman -S snort

## set up posgresql

    pacman -S postgresql

    adduser postgres
    mkdir /usr/local/pgsql/data
    chown postgres /usr/local/pgsql/data
    su - postgres
    /usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data
    /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data >logfile 2>&1 &
    /usr/local/pgsql/bin/createdb test
    /usr/local/pgsql/bin/psql test

## Configure boot

NOTE: we probably don't need to start postgresql and nginx when using monitd

add iptables ip6tables postgresql nginx monitd to DAEMONS
    
    cp /etc/rc.conf /etc/rc.conf-orig
    sed -e '/^DAEMONS/{ s/^/# /
      aDAEMONS=(syslog-ng network iptables ip6tables crond sshd postgresql nginx postfix monitd)
      }' \
    /etc/rc.conf-orig >/etc/rc.conf
    cat /etc/rc.conf

## Create user mike

    adduser -G monit mike

    (fill in as appropriate)

    chmod 711 /home/mike

    sudo su - mike

    mkdir htdocs
    chgrp nginx htdocs
    chmod 755 htdocs
    chmod g+s htdocs

Add mike to sudoer's

    vi /etc/sudoers
    (add mike as equivalent to root)
    
## As user 'mike'

### install rvm

    bash < <(curl -s https://rvm.beginrescueend.com/install/rvm)

### install ruby 1.9.2

    rvm install 1.9.2
    (wait)
    rvm use 1.9.2 --default
    
    gem install bundler
